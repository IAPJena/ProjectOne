function opticalSystemObject = importZemaxFile (zmxFullFileName,...
        coatingCatalogueListFullNames,glassCatalogueListFullNames,dispWarnings)
    % importZemaxFile: imports lens data from .zmx file format generated by zemax.
    % when unsupported feature is found, display the command in the command window.
    % Input:
    % 	zmxFullFileName: Full file name of .zmx file including its path.
    % Output:
    %	opticalSystemObject: Optical system object
    
    
    % <<<<<<<<<<<<<<<<<<<<<<< Algorithm Section>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    
    % <<<<<<<<<<<<<<<<<<<<<<<<< Example Usage>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    %
    
    % <<<<<<<<<<<<<<<<<<<<<<<<< Author Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>
    %   Written By: Worku, Norman Girma
    %   Advisor: Prof. Herbert Gross
    %	Optical System Design and Simulation Research Group
    %   Institute of Applied Physics
    %   Friedrich-Schiller-University of Jena
    
    % <<<<<<<<<<<<<<<<<<< Change History Section >>>>>>>>>>>>>>>>>>>>>>>>>>
    % Date----------Modified By ---------Modification Detail--------Remark
    % Oct 14,2013   Worku, Norman G.     Original Version       Version 3.0
    
    % <<<<<<<<<<<<<<<<<<<<< Main Code Section >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    if nargin < 4
        dispWarnings = 0;
    end
    if nargin < 3
        glassCatalogueListFullNames = getAllObjectCatalogues('Glass');
    end
    if nargin < 2
        coatingCatalogueListFullNames = getAllObjectCatalogues('Coating');
    end
    if nargin < 1
        
        [FileName,PathName] = uigetfile('*.zmx','Select ZMX File');
        if ~isempty(FileName)&&~isempty(PathName) && ...
                ~isnumeric(FileName) && ~isnumeric(PathName)
            zmxFullFileName = [PathName,FileName];
        else
            opticalSystemObject = OpticalSystem;
            return;
        end
    end
    
    % create an empty optical system object
    mySystem = OpticalSystem;
    surfCounter = 0;
    nSurf = 0;
    
    % convert unicode to ascii format running DOS command
    command = ['TYPE "',zmxFullFileName,'">"temAnsiFile"'];
    status = dos(command);
    
    % read the input file
    inputFile = fopen('temAnsiFile', 'r');
    
    % locate the beginning of the file
    currentPos = ftell(inputFile);
    
    % read the next valid line
    skipNextLineRead = 0;
    currentLine = readNextLine(inputFile);
    disp(' ');
    disp('Started: Importing system configuration data...');
    while ( ~strcmpi(currentLine,'EOF') )
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        
        % The first element of the array is the 4 character zmx command
        zmxCommand = char(currentLineArray(1,:));
        
        switch zmxCommand
            case 'VERS'
                % The version number of Zemax file used to create the .zmx file.
                zmxVersion = char(currentLineArray(2,:));
                year = str2num(zmxVersion(1:2));
                if year < 13
                    choice = questdlg(['Your zemax file is generated using Zemax version ',...
                        zmxVersion,...
                        '. But this toolbox supports Zemax version 13 or later files. Do you want to try any way?'], ...
                        'Old version ZMX File', ...
                        'Yes','No','Yes');
                    % Handle response
                    switch choice
                        case 'Yes'
                            if dispWarnings
                                disp(['Zemax Version ','Warning: Your zemax file is generated using older version of Zemax (older the Zemax 13). So the import may fail.']);
                            end
                        case 'No'
                            opticalSystemObject = OpticalSystem;
                            return;
                    end
                end
            case 'ENPD'
                % ENPD val	: Entrance Pupil Diameter Value
                mySystem.SystemApertureType = 1;
                mySystem.SystemApertureValue = (str2num(char(currentLineArray(2,:))));
            case 'ENVD'
                % ENVD temp pres on	: Environment data. The temp and pres values are in
                % degrees c and atmospheres, respectively. On = 0 or 1: Indicate whether to adjust index to environment data (1) or not (0).
                if dispWarnings
                    disp(['Environment data ','Unsupported command : ',currentLine]);
                end
            case 'FLOA'
                % FLOA val	: Float by stop size. val is just ignored
                mySystem.SystemApertureType = 3; %Float by stop size
                %                 if dispWarnings
                %                     disp(['Float by stop size ','Unsupported command : ',currentLine]);
                %                 end
            case 'FNUM'
                % FNUM  val I	I = 0:Image Space F/# Value I = 1:Paraxial Working F/#
                if dispWarnings
                    disp(['F number ','Unsupported command : ',currentLine]);
                end
            case 'SDMA'
                % SDMA (marigin%) (fastsmd) (marigin)
                % marigin%: Semi diameter margin
                % Marigin: Semi diameter margin meters
                % fastsmd : is 1 if “Fast Semi-Diameters” is selected otherwise it is 0.
                marginPercent = str2num(char(currentLineArray(2,:)));
                fastsmd = str2num(char(currentLineArray(3,:)));
                marigin = str2num(char(currentLineArray(4,:)));
                mySystem.SurfaceMarginPercent = marginPercent;
                mySystem.FastSemidiameter = fastsmd;
                mySystem.SurfaceMarginAdditional = marigin;
            case 'FTYP'
                % FTYP type ??0 nfieldpts nWavelength  fieldnorm ??0 ??0	: Field Type.
                % Type = 0,1,2,3 for Angle, Object Height, Paraxial Image Height, and Real Image Height respectively.
                % Nfieldpts: number of field points selected.
                % nWavelength : number of wavelengths selected.
                % Fieldnorm: 0,1 for Radial and Rectangular field normalization.
                ftype = str2num(char(currentLineArray(2,:)));
                if ftype == 0
                    mySystem.FieldType = 2; %'Angle';
                elseif ftype == 1
                    mySystem.FieldType = 1; %'ObjectHeight';
                else
                    disp(['Error: Unsupported Field Type. Only Angle and ObjectHeight field value are supported!! So edit the field type.']);
                end
                
                nfieldpts = str2num(char(currentLineArray(4,:)));
                mySystem.NumberOfFieldPoints = nfieldpts;
                mySystem.FieldPointMatrix = repmat([0,0,1],[nfieldpts,1]);
                
                nwavelengths = str2num(char(currentLineArray(5,:)));
                mySystem.NumberOfWavelengths = nwavelengths;
                mySystem.WavelengthMatrix = repmat([0,1],[nwavelengths,1]);
                
                fnorm = str2num(char(currentLineArray(6,:)));
                if fnorm == 0
                    mySystem. FieldNormalization = 2; %'Radial';
                else
                    mySystem. FieldNormalization = 1; %'Rectangular';
                end
            case 'XFLN'
                % XFLN val1 val2 val3...	The x field values (total 12)
                % number of field points defined
                nFieldPoint = mySystem.NumberOfFieldPoints;
                mySystem.FieldPointMatrix(:,1)= str2num(char((currentLineArray(2:nFieldPoint+1))));
            case 'YFLN'
                % YFLN val1 val2 val3...	The y field values (total 12)
                % number of field points defined
                nFieldPoint = mySystem.NumberOfFieldPoints;
                mySystem.FieldPointMatrix(:,2)= str2num(char((currentLineArray(2:nFieldPoint+1))));
            case 'FWGN'
                % FWGN val1 val2 val3...	Field weights (total 12)
                % number of field points defined
                nFieldPoint = mySystem.NumberOfFieldPoints;
                mySystem.FieldPointMatrix(:,3)= str2num(char((currentLineArray(2:nFieldPoint+1))));
                
            case 'GCAT'
                % GCAT name1 name2 name3 ...	Indicates which glass catalogs are used by the lens.
                % Future: Add function to import the glass catalogues on request
                disp(char(['Glass catalogues used:',(currentLineArray(2:end))']));
                
                % Check for the existance of the correspoding catalogues in
                % the toolbox.
                for kk = 2:size(currentLineArray,1)
                    catName = [char(currentLineArray(kk,:)),'_AGF'];
                    catFound = 0;
                    for pp = 1:size(glassCatalogueListFullNames,1)
                        glassCatalogueListFullName = glassCatalogueListFullNames{pp};
                        [glassCataloguePath,glassCatalogueName,ext] = fileparts(glassCatalogueListFullName);
                        
                        if strcmpi(glassCatalogueName,catName)
                            catFound = 1;
                            break;
                        end
                    end
                    if ~catFound
                        % Construct a questdlg with three options
                        choice = questdlg(['The glass catalogue ',catName,' is not found. Do you want to import it now?'], ...
                            'Missing Glass Catalogue', ...
                            'Yes','Cancel','Yes');
                        % Handle response
                        switch choice
                            case 'Yes'
                                [ ~, catalogueFullFileName ] = importAGFGlassCatalogue();
                                glassCatalogueListFullNames = [glassCatalogueListFullNames;{catalogueFullFileName}];
                            case 'Cancel'
                                disp(['Glass Catalogue ','Warning: Missing glass catalogue. The glass catalogue :',catName,' is just ignored.']);
                                %                                 return;
                        end
                    end
                end
                
            case 'GFAC'
                % GFAC val type	:Apodization factor value and type. The type code is 0
                % for none, 1 for Gaussian, and 2 for cosine cubed.
                apodVal = str2num(char(currentLineArray(2,:)));
                apodType = str2num(char(currentLineArray(3,:)));
                if apodType == 0
                    mySystem.ApodizationType = 1; %'None';
                elseif apodType == 1
                    disp(['Apodization ','Warning: It is not possible to import Gaussian apodization parameters.']);
                    % ApodizationType = 'Super Gaussian';
                    % ApodizationParameters.MaximumIntensity =
                    % ApodizationParameters.Order = 2;
                    % ApodizationParameters.BeamRadius =
                else
                    if dispWarnings
                        disp(['Apodization ','Warning: Cosine cubed apodization is not supported.']);
                    end
                    
                end
            case 'GLRS'
                % GLRS surf f#comp	:Global Surface
                % Surf: index of global surface.
                % f#comp: 0,1 if method to compute F/# = “tracing rays” and “pupil size/position” respectively.
                disp(['Global Surface ','Warning: Global reference surface is ignored and',...
                    ' it is just fixed to the first surface.'])
            case 'MODE'
                % MODE SEQ	SEQ =  Sequential Mode or Hybrid
                % NSQ =  Non-sequential Mode
                mode = char(currentLineArray(2,:));
                if strcmpi(mode,'NSC')
                    if dispWarnings
                        disp(['Mode ','Error: Non sequential system is not supported']);
                        return;
                    end
                    
                end
            case 'NAME'
                % NAME name	: Name of the lens
                if size(currentLineArray,2) == 2
                    mySystem.LensName = char(currentLineArray(2,:));
                else
                    mySystem.LensName = 'Untitled';
                end
            case 'NOTE'
                % NOTE I Notes...	Notes related to the lens
                % I = {0, 4} ??
                if size(currentLineArray,1) == 3
                    mySystem.LensNote = char(currentLineArray(3,:));
                end
            case 'NSCD'
                % NSCD maxInter maxSeg minAbsInt minRelInt maxObj glueDist
                % retrace ??0 ??0 ??0 misdRayDrawDist ??1 maxSrcRay simpRaySplit
                % ??2	: Non-sequential data
                % maxInter:maximum intersection per ray
                % maxSeg: maximum segments per ray
                % minAbsInt: minimum absolute ray intensity
                % minRelInt: minimum relative ray intensity
                % maxObj: maximum nested/touching objects
                % glueDist: glue distance in lens units
                % retrace: 1 if “Retrace source rays upon file open” is selected and 0 otherwise
                % ??0 ??0 ??0
                % misdRayDrawDist: missed ray draw distance in lens units
                % ??1
                % maxSrcRay: maximum source file rays in memory
                % simpRaySplit: 1 if “Simple ray splitting” is selected and 0 otherwise
                % ??2
                disp(['Error: Non-sequential data is not supported so all are ignored.']);
            case 'OBNA'
                % OBNA val I	I = 0:Object Space NA and I = 1: object cone angle
                value = str2num(char(currentLineArray(2,:)));
                I = str2num(char(currentLineArray(3,:)));
                if I == 0
                    mySystem.SystemApertureType = 2;
                    mySystem.SystemApertureValue = value;
                else
                    if dispWarnings
                        disp(['Warning: Object cone angle is not supported ',...
                            'so it is considered as object NA.']);
                    end
                    mySystem.SystemApertureType = 2;
                    mySystem.SystemApertureValue = value;
                end
                
            case 'PICB'
                % PICB i	: Paraxial Ignore Coordinate Breaks,
                % i = 0 is false, i = 1 is true. Default is true.
                if dispWarnings
                    disp(['Paraxial Ignore Coordinate Breaks ','Unsupported command : ',currentLine]);
                end
            case 'POLS'
                % POLS unpol Ex Ey Phax Phay thinfilmtorayconvert refMethod :	Dafault polarization state used.
                % Unpol is 1 if “Unpolarized” is selected otherwise it is 0.
                % Thinfilmtorayconvert is 1 if “Convert thin film phase to ray equivalent” is selected otherwise it is 0.
                % refMethod is 0,1,2 for X-, Y- and Z-Axis reference method.
                unpol = str2num(char(currentLineArray(2,:)));
                Ex = str2num(char(currentLineArray(3,:)));
                Ey = str2num(char(currentLineArray(4,:)));
                Phax = str2num(char(currentLineArray(5,:)));
                Phay = str2num(char(currentLineArray(6,:)));
                thinfilmtorayconvert = str2num(char(currentLineArray(7,:)));
                refMethod = str2num(char(currentLineArray(8,:)));
                if dispWarnings
                    disp(['Dafault polarization ','Unsupported command : ',currentLine]);
                end
            case 'PUSH'
                % PUSH pupilshiftz pupilshifty pupilshiftx scalepupilshift pupilcompressx pupilcompressy	Pupil shift. All values indicate the corresponding values in the General system window.
                % Scalepupilshift is 1 if “Scale Pupil Shift factors by field” is selected else it is 0.
                if dispWarnings
                    disp(['Pupil shift ','Unsupported command : ',currentLine]);
                end
            case 'RAIM'
                % RAIM tol type ?? fastasphere usecache grinaper robust
                % threadingoff dontprintcoordbreak opd2modpi	: The ray aiming and a few other settings.
                % Fastasphere is 1
                % if the "Fast Asphere Trace" is selected, otherwise it is
                % 0.
                % Threadingoff is 1 if “Turn Off Threading” is selected, otherwise 0.
                % Grinaper is 1 if "Check Grin
                % Aper" is selected, otherwise it is 0.
                % Dontprintcoordbreak is 1 if “Don’t Print Coordinate Break Data” is selected, otherwise 0.
                % Tol is
                % no longer used, but some value (such as zero) must
                % be present as a placeholder.
                % Type is 0, 1, or 2 for
                % None, Paraxial, or Real ray aiming.
                % opd2modpi is 1 if “OPD Modulo 2 pi” is selected, otherwise 0.
                %
                % Usecache is 1 if "Use Ray Aiming Cache" is
                % selected, otherwise it is 0.
                % Robust is 1 if
                % "Robust Ray Aiming" is selected, otherwise it is 0.
                if dispWarnings
                    disp(['Ray aiming ','Unsupported command : ',currentLine]);
                end
            case 'ROPD'
                % ROPD i	Reference OPD setting. For i = 0, 1, 2, and 3, the
                % reference point is Absolute, Infinity,Exit Pupil, and Absolute 2 respectively. Use Exit Pupil as the default.
                if dispWarnings
                    disp(['Reference OPD ','Warning: The reference OPD setting is ignored. ',...
                        'It is usually at Exit pupil.']);
                end
                
            case 'SCAT'
                % SCAT model fraction angle ??“”	Scattering
                % Model: Scattering model. 0(No Scattering),1(Lamberitian),2(Gaussian),3(ABg),4(ABg file),5(BSDF),6(IS Scatter Catalogue),7(User Defined)
                % Fraction: Scatter fraction
                % Angle: Angle
                % ??“”
                if dispWarnings
                    disp(['Scattering ','Unsupported command : ',currentLine]);
                end
            case 'UNIT'
                % UNIT LensUnit SourceUnitPrefix SourceUnit
                % AnalysisUnitPrefix AnalysisUnit AfocalModeUnit
                % MTFUnit
                % LensUnit {MM,CM,IN,METER}
                % SourceUnitPrefix {F,P,N,U,M,X,K,E,G,T}
                % SourceUnit{W,L,J}
                % AnalysisUnitPrefix{F,P,N,M,G}
                % AnalysisUnit{MM,CM,IN,ME,FT}
                % AfocalModeUnit{UR,MR,RR,AS,AM,DG}
                % MTFUnit{CPMM,CPMR}
                %
                LENSUNIT = char(currentLineArray(2,:));
                if strcmpi(LENSUNIT,'MM')
                    lensUnit = 1;
                elseif strcmpi(LENSUNIT,'CM')
                    lensUnit = 2;
                elseif strcmpi(LENSUNIT,'IN')
                    lensUnit = 4;
                elseif strcmpi(LENSUNIT,'METER')
                    lensUnit = 3;
                else
                end
                wavUnit = 2; % Wavelength is always in microns in ZMX
                
                mySystem.WavelengthUnit = wavUnit;
                mySystem.LensUnit = lensUnit;
                if dispWarnings
                    disp(['Warning: Only lens and wavelength units are supported.']);
                end
            case {'VANN','VCXN','VCYN','VDXN','VDYN'}
                % VANN val1 val2 val3...	VAN vignating factors (total 12)
                if dispWarnings
                    disp(['Warning: Vignating factors ','Unsupported command : ',currentLine]);
                end
            case 'WAVM'
                % WAVM N wavlen weight	: Wavelength
                % N = 1,2,…24 indicating the wavelength index
                % Wavlen: the waveleght value
                % Weight: corresponding weight
                nwav = mySystem.NumberOfWavelengths;
                N = str2num(char(currentLineArray(2,:)));
                wavlen = str2num(char(currentLineArray(3,:)));
                weight = str2num(char(currentLineArray(4,:)));
                if N <= nwav
                    mySystem.WavelengthMatrix(N,1) = wavlen;
                    mySystem.WavelengthMatrix(N,2) = weight;
                end
            case 'PWAV'
                % PWAV ind	: Primary wavelength index (starts from 1).
                mySystem.PrimaryWavelengthIndex = str2num(char(currentLineArray(2,:)));
            case 'SURF'
                % SURF index	Surface index starting from 0 @ object surface.
                disp('Completed: Importing system configuration data.');
                disp(' ');
                disp('Started: Importing surface data...');
                [surfArray,nonDummySurfaceIndices,nextZmxCommand] = readSurfaceArray(inputFile,...
                    coatingCatalogueListFullNames,glassCatalogueListFullNames,mySystem,dispWarnings);
                
                mySystem.SurfaceArray = surfArray;
                mySystem.NumberOfSurfaces = length(surfArray);
                mySystem.NonDummySurfaceArray  = surfArray(nonDummySurfaceIndices);
                mySystem.NumberOfNonDummySurfaces = length(nonDummySurfaceIndices);
                mySystem.NonDummySurfaceIndices = nonDummySurfaceIndices;
                
                % Skip readLine for the next command as it is already read
                % by the readSurfaceArray function
                skipNextLineRead = 1;
                disp('Completed: Importing surface data.');
                disp(' ');
            case 'MFDS'
                disp('Started: Importing Merit function data...');
                [meritFunction,nextZmxCommand] = readMeritFunction(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readMeritFunction function
                skipNextLineRead = 1;
                disp('Completed: Importing Merit function data.');
                disp(' ');
            case 'MNUM'
                % MNUM n ??1	Number of configuration
                disp('Started: Importing Multi-configuration data...');
                [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readMultiConfigurationData function
                skipNextLineRead = 1;
                disp('Completed: Importing Multi-configuration data.');
                disp(' ');
            case 'TOL'
                disp('Started: Importing Tolerance data...');
                [toleranceData,nextZmxCommand] = readToleranceData(inputFile);
                % Skip readLine for the next command as it is already read
                % by the readToleranceData function
                skipNextLineRead = 1;
                disp('Completed: Importing Tolerance data.');
                disp(' ');
                %additional commands in optic studio 15
            case 'LANG'
                
            case 'REAY'
        end
        % read the next valid line
        if skipNextLineRead
            currentLine = nextZmxCommand;
            skipNextLineRead = 0;
        else
            currentLine = readNextLine(inputFile);
        end
    end
    nSurf = size(mySystem.SurfaceArray,2);
    mySystem.NumberOfSurfaces =  nSurf;
    mySystem.SurfaceArray(1).IsObject = 1;
    mySystem.SurfaceArray(nSurf).IsImage = 1;
    % Save all surfaces as optical elements
    nElement = nSurf;
    for kk = 1:nElement
        mySystem.OpticalElementArray{kk} = mySystem.SurfaceArray(kk);
    end   
    
    %
    % Save all surfaces as components SS
    nComponent = mySystem.NumberOfSurfaces;
    mySystem.NumberOfComponents = nComponent;
    for kk = 1:nComponent
        mySystem.ComponentArray(kk).Type = 'SS';
        mySystem.ComponentArray(kk).Parameters.NumberOfSurfaces = 1;
        mySystem.ComponentArray(kk).Parameters.SurfaceArray = mySystem.SurfaceArray(kk);
    end
    
   opticalSystemObject = updateOpticalSystem( mySystem );
end

%%%%%%%%%%%%%%%%%%%%%%%
function nextLine =  readNextLine(inputFile)
    line = (fgets(inputFile));
    if ischar(line)
        nxtL = strtrim(line);
        % nxtL(2:2:length(nxtL)) = '';
        if length(line)< 3
            % invalid line just skip
            disp(['Read next line ','Error: Invalid zmx command line found.']);
            nextLine =  readNextLine(inputFile);
        end
    else
        nxtL = 'EOF';
    end
    
    nextLine = nxtL;
    
end

%%%%%%%%%%%%%%%%%%%%%%%
function [meritFunction,nextZmxCommand] = readMeritFunction(inputFile)
    disp('Currently merit functions can not be imported. So all are just ignored');
    % Ignore all lines of text, until we see one that just consists of this:
    % {'MNUM','TOL','CSUM'}
    while 1
        currentLine = readNextLine(inputFile);
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        % The first element of the array is the 4 character zmx command
        zmxSurfCommand = char(currentLineArray(1,:));
        
        % Break if we hit end of file, or the start marker
        if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MNUM')...
                ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')
            break
        end
    end
    meritFunction = 'No merit function';
    nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [multiConfigData,nextZmxCommand] = readMultiConfigurationData(inputFile)
    disp('Currently multi-configuration data can not be imported. So all are just ignored');
    % Ignore all lines of text, until we see one that just consists of
    % this:{'MFDS', 'TOL','CSUM'}
    while 1
        currentLine = readNextLine(inputFile);
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        % The first element of the array is the 4 character zmx command
        zmxSurfCommand = char(currentLineArray(1,:));
        
        % Break if we hit end of file, or the start marker
        if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
                ||  strcmp(zmxSurfCommand, 'TOL') ||strcmp(zmxSurfCommand, 'CSUM')...
                ||strcmp(zmxSurfCommand, 'EOF')
            break
        end
    end
    multiConfigData = 'No multi configuration data';
    nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [toleranceData,nextZmxCommand] = readToleranceData(inputFile)
    disp('Currently tolerance data can not be imported. So all are just ignored');
    % Ignore all lines of text, until we see one that just consists of
    % this:{'MFDS', 'MNUM','CSUM'}
    while 1
        currentLine = readNextLine(inputFile);
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        % The first element of the array is the 4 character zmx command
        zmxSurfCommand = char(currentLineArray(1,:));
        
        % Break if we hit end of file, or the start marker
        if ~ischar(currentLine)  ||  strcmp(zmxSurfCommand, 'MFDS')...
                ||  strcmp(zmxSurfCommand, 'MNUM') ||strcmp(zmxSurfCommand, 'CSUM')
            break
        end
    end
    toleranceData = 'No Tolerance Data';
    nextZmxCommand = zmxSurfCommand;
end

%%%%%%%%%%%%%%%%%%%%%%%
function [surfaceObjectArray,nonDummySurfaceIndices,nextZmxCommand] = readSurfaceArray(inputFile,...
        coatingCatalogueListFullNames,glassCatalogueListFullNames,mySystem,dispWarnings)
    surfaceCounter = 1;
    nonDummySurface = ones(1,100);
    surfaceObjectArray(surfaceCounter) = Surface;
    
    currentLine = readNextLine(inputFile);
    % read the line as space separated string
    currentLineArray = strread(currentLine,'%s');
    % The first element of the array is the 4 character zmx command
    zmxSurfCommand = char(currentLineArray(1,:));
    endOfSurfaceDefinition = 0;
    
    while ~endOfSurfaceDefinition
        switch zmxSurfCommand
            case 'HIDE'
                % HIDE hideRays noEdgesDraw noSurfDraw rowColor noHyperHemisph
                % surfIgnore edgeDrawType skipRays drawLocalAx ??0
                % Setting to show/hide surface comps.
                % hideRays: is 1 if “Hide Rays To This Surface” is selected otherwise is 0.
                % noEdgesDraw: is 1 if “Don’t Draw Edges From This Surface” is selected otherwise is 0.
                % noSurfDraw: is 1 if “Don’t Draw This Surface” is selected otherwise is 0.
                % rowColor: 0(Default),1(Color 1),…,24(color 24),25(no color).
                % noHyperHemisph: is 1 if “Surface Can’t Be Hyperhemispheric” is selected otherwise is 0.
                % surfIgnore: is 1 if “Ignore This Surface” is selected otherwise is 0.
                % edgeDrawType: 0(Squared to Next Surface),1(Tapered To Next Surface),2(Flat To Next Surface)
                % skipRays: is 1 if “Skip Rays To This Surface” is selected otherwise is 0.
                % drawLocalAx: is 1 if “Draw Local Axis” is selected otherwise is 0.
                %  ??0
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),...
                        ' Warning: Hide setting (HIDE) is just ignored for now.']);
                end
            case 'POPS'
                % POPS autoResample useRays don'tRescaleBeamSize UseAngSpectProp OutputPilotRad DrawBeamFile Resample XSamp 1=32,2=64,...) YSamp XWidth  YWidth ??0 XRad YRad useXAxisRef	Physical optics propagation data
                % autoResample: is 1 if “Auto Resample” is selected and 0 otherwise.
                % useRays: is 1 if “Use Rays To Propagate To Next Surface” is selected and 0 otherwise.
                % don'tRescaleBeamSize: is 1 if “Don not Rescale Beam Size Using Ray Data” is selected and 0 otherwise.
                % UseAngSpectProp: is 1 if “Use Angular Spectrum Propagator” is selected and 0 otherwise.
                % OutputPilotRad: 0:Best fit 1:shorter 2:longer 3:X 4:Y 5:Plane 6:User
                % DrawBeamFile: is 1 if “Draw Beamfile On Shaded Model” is selected and 0 otherwise.
                % Resample: is 1 if “Resample After Refraction” is selected and 0 otherwise.
                % XSamp: X-Sampling 1=32,2=64,...10=16384
                % YSamp: Y-Sampling 1=32,2=64,...10=16384
                % XWidth: X-Width
                % YWidth: Y-Width
                % ??0
                % XRad: X-Radius
                % YRad: Y-Radius
                % useXAxisRef: is 1 if “Use X-Axis Reference” is selected and 0 otherwise.
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),...
                        ' Warning: Physical Optics Propagation (POPS) is just ignored for now..']);
                end
            case 'MIRR'
                % MIRR substShape substThick	The mirror substrate.
                % substShape: 0(None),1(Flat),2(Curved)
                % substThick: substrate thickness
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Mirror substrate data (MIRR) is not supported. It is always curved.']);
                end
            case 'CLAP'
                % CLAP min max surfPickup	:Circular Aperture min and max radius. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    
                    minRadius = str2num(char(currentLineArray(2,:)));
                    maxRadius = str2num(char(currentLineArray(3,:)));
                    surfPickup = str2num(char(currentLineArray(4,:)));
                    
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    
                    minimumRadius = minRadius*apertureFactorX;
                    maximumRadius = maxRadius*apertureFactorY;
                    
                    surfaceObjectArray(surfaceCounter).Aperture = Aperture('CircularAperture');
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.SmallDiameter = 2*minimumRadius;
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.LargeDiameter = 2*maximumRadius;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                    if dispWarnings
                        if surfPickup
                            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                                'aperture pickup is not supported.' ]);
                        end
                    end
                end
            case 'ELAP'
                % ELAP xHalfWid yHalfWid surfPickup	: Elliptical aperture x and y half width. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    xHalfWid = str2num(char(currentLineArray(2,:)));
                    yHalfWid = str2num(char(currentLineArray(3,:)));
                    surfPickup = str2num(char(currentLineArray(4,:)));
                    
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    
                    halfWidthX = xHalfWid*apertureFactorX;
                    halfWidthY = yHalfWid*apertureFactorY;
                    
                    surfaceObjectArray(surfaceCounter).Aperture = Aperture('EllipticalAperture');
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.DiameterX = 2*halfWidthX;
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.DiameterY = 2*halfWidthY;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                    if dispWarnings
                        if surfPickup
                            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                                'aperture pickup is not supported.' ]);
                        end
                    end
                end
            case 'ELOB'
                % ELOB xHalfWid yHalfWid surfPickup	: Elliptical aperture x and y half width. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                        'aperture is not supported.' ]);
                end
            case 'FLAP'
                % FLAP 0 semiDiam surfPickup	: Floating Aperture
                % semiDiam: Semi-diameter
                % surfPickup: Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    semiDiam = str2num(char(currentLineArray(3,:)));
                    surfPickup = str2num(char(currentLineArray(4,:)));
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    
                    semiDiamX = semiDiam*apertureFactorX;
                    semiDiamY = semiDiam*apertureFactorY;
                    
                    % Currently floating aperture could only be circular so
                    % take the max of both % Use the max value as radius
                    maxSemiDiam = max([semiDiamX,semiDiamY]);
                    surfaceObjectArray(surfaceCounter).Aperture = Aperture('FloatingCircularAperture');
                    % To make sure that the system is imported correctly all
                    % flaoting circular apertures shall be replaced with fixed
                    % circular apertures.
                    %surfaceObjectArray(surfaceCounter).Aperture = Aperture('CircularAperture');
                    
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.Diameter = 2*maxSemiDiam;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                    
                    if dispWarnings
                        if surfPickup
                            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                                'aperture pickup is not supported.' ]);
                        end
                    end
                end
            case 'OBDC'
                % OBDC xdec ydec	Aperture and Obscuration decenter in x and y direction.
                if ~surfaceApertureIsSet
                    xdec = str2num(char(currentLineArray(2,:)));
                    ydec = str2num(char(currentLineArray(3,:)));
                    aperParam = surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters;
                    aperParam(3) = xdec;
                    aperParam(4) = ydec;
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters = aperParam;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                end
            case 'OBSC'
                % OBSC min max surfPickup	Circular Obscuration min and max radius. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    minRadius = str2num(char(currentLineArray(2,:)));
                    maxRadius = str2num(char(currentLineArray(3,:)));
                    surfPickup = str2num(char(currentLineArray(4,:)));
                    
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    
                    minimumRadius = minRadius*apertureFactorX;
                    maximumRadius = maxRadius*apertureFactorY;
                    
                    surfaceObjectArray(surfaceCounter).Aperture = Aperture('CircularObstruction');
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.SmallDiameter = 2*minimumRadius;
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.LargeDiameter = 2*maximumRadius;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                    if dispWarnings
                        if surfPickup
                            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                                'aperture pickup is not supported.' ]);
                        end
                    end
                end
            case 'SPID'
                % SPID widArms numbArms surfPickup	Spider width of Arm and number of arms. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: Spider '...
                        'aperture is not supported.' ]);
                end
            case 'SQAP'
                % SQAP xHalfWid yHalfWid surfPickup	Rectangular aperture x and y half width. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    xHalfWid = str2num(char(currentLineArray(2,:)));
                    yHalfWid = str2num(char(currentLineArray(3,:)));
                    surfPickup = str2num(char(currentLineArray(4,:)));
                    
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    halfWidthX = xHalfWid*apertureFactorX;
                    halfWidthY = yHalfWid*apertureFactorY;
                    
                    surfaceObjectArray(surfaceCounter).Aperture = Aperture('RectangularAperture');
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.DiameterX = 2*halfWidthX;
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.DiameterY = 2*halfWidthY;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    if surfaceApertureIsFixedSize
                         surfaceObjectArray(surfaceCounter).Aperture.DrawAbsolute = 1;
                    end
                    if dispWarnings
                        if surfPickup
                            disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                                'aperture pickup is not supported.' ]);
                        end
                    end
                end
            case 'SQOB'
                % SQOB xHalfWid yHalfWid surfPickup	Rectangular Obscuration x and y half width. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                        'aperture is not supported.' ]);
                end
            case 'UDAD'
                % UDAD I x y z	User defined aperture data. The first line is always <UDAD 0 “name.uda” UDAsclae>, then for I = 1,2,… the x and y data points corresponding to the user defined aperture are presented.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: User defined '...
                        'aperture is not supported.' ]);
                end
            case 'USAP'
                % USAP min max surfPickup	User aperture. Index of Pickup surface otherwise 0.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: User defined '...
                        'aperture is not supported.' ]);
                end
            case 'USOB'
                % USOB min max surfPickup	User Obscuration.
                if ~surfaceApertureIsSet
                    disp(['Surf ',num2str(surfaceCounter),'Error: Obscuration '...
                        'aperture is not supported.' ]);
                end
            case 'COAT'
                % COAT name :	The name of coating (if any)
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Importing '...
                        'coating is not fully supported. Needs checking.' ]);
                end
                % coating data
                coatName = char(currentLineArray(2,:));
                if ~isempty(coatName)
                    % check for its existance and extract the coating among selected catalogues
                    objectType = 'coating';
                    objectName = coatName;
                    
                    objectCatalogueListFullNames = coatingCatalogueListFullNames;
                    objectIndex = 0;
                    for pp = 1:size(objectCatalogueListFullNames,1)
                        objectCatalogueFullName = objectCatalogueListFullNames{pp};
                        [ aodObject,objectIndex ] = extractObjectFromObjectCatalogue...
                            (objectType,objectName,objectCatalogueFullName );
                        if objectIndex ~= 0
                            break;
                        end
                    end
                    
                    if  objectIndex ~= 0
                        surfaceObjectArray(surfaceCounter).Coating = aodObject;
                    else
                        disp(['Surf ',num2str(surfaceCounter),' Error: The coating of surface ',num2str(surfaceCounter),' is not found so it is ignored.']);
                        surfaceObjectArray(surfaceCounter).Coating = Coating;
                    end
                else
                    surfaceObjectArray(surfaceCounter).Coating = Coating;
                end
                
            case 'COMM'
                % COMM comment	Comment on the surface.
                surfaceObjectArray(surfaceCounter).Comment = (char(currentLineArray(2,:)));
            case 'CONI'
                % CONI val	Conic constant of the surface.
                conic = str2num(char(currentLineArray(2,:)));
                surfaceObjectArray(surfaceCounter).Conic = conic;
            case 'VCON'
                % VCON	Variable conic constant.
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                        'constant solve/pickup is not supported.' ]);
                end
            case 'PKUP'
                % PKUP Surf scale Col	Conic Constant pickup.
                % Surf: From Surface index
                % Scale: Scale factor
                % Col: Pickup Column. 0(current),1(radius),2(thickness),3(conic),4(semidiameter),5(
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Conic '...
                        'constant solve/pickup is not supported.' ]);
                end
            case 'CURV'
                % CURV val solveType param1 param2 param3 param4	The surface curvature.
                % Val: value of the curvature
                % solveType = 0 (fixed), 1(variable),2,3,… indicating the solve types (see the solves chapter from Zemax manual)
                % param1…4 : Solve parameters
                %
                curv = str2num(char(currentLineArray(2,:)));
                solve = str2num(char(currentLineArray(3,:)));
                surfaceObjectArray(surfaceCounter).Radius = 1/curv;
                if dispWarnings
                    if solve
                        disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                            'curvature solve/pickup is not supported.' ]);
                    end
                end
            case 'SCOL'
                % SCOL colIndex transparency	Surface Color.
                % colIndex: 0(default), 1-24(d/t color index)
                % transparency: (100 - Surface Opacity%)/10
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                        'color is not supported.' ]);
                end
            case 'SLAB'
                % SLAB val	Surface labels.
                % Val: unique integer assigned to each surface to identify the surface as new surfaces are inserted or old ones deleted. This can be used to know where a surface has moved to in the list of surfaces.
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Surface '...
                        'label is not supported.' ]);
                end
            case 'STOP'
                % STOP	Marks Stop Surface.
                surfaceObjectArray(surfaceCounter).StopSurfaceIndex = 1;
            case 'SURF'
                % SURF index	Surface index starting from 0 @ object surface.
                surfaceCounter = surfaceCounter + 1;
                surfaceApertureIsSet = 0;
                surfaceApertureIsFixedSize = 0;
                surfaceObjectArray(surfaceCounter) = Surface();
                disp(' ');
                
            case 'TYPE'
                % TYPE surfType: 	surfType = STANDARD,EVENASPH,ODDASPHE...
                % Surface types supported are STANDARD, TILTSURF, DGRATING,
                % COORDBRK,EVENASPH,TOROIDAL
                % STANDARD, TILTSURF, DGRATING => Standard
                % COORDBRK => Dummy
                % PARAXIAL => IdealLens
                % EVENASPH => EvenAsphere
                % TOROIDAL => Toroidal
                
                zemaxSurfaceType = char(currentLineArray(2,:));
                supportedSurfaceTypes = GetSupportedSurfaceTypes();
                if strcmpi(zemaxSurfaceType,'STANDARD')||...
                        strcmpi(zemaxSurfaceType,'TILTSURF')||...
                        strcmpi(zemaxSurfaceType,'DGRATING')
                    [~,locationIndex] = ismember('Standard',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;
                elseif strcmpi(zemaxSurfaceType,'COORDBRK')
                    [~,locationIndex] = ismember('Dummy',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;
                    nonDummySurface(surfaceCounter) = 0;
                elseif strcmpi(zemaxSurfaceType,'PARAXIAL')
                    [~,locationIndex] = ismember('IdealLens',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;  
                elseif strcmpi(zemaxSurfaceType,'EVENASPH')
                    [~,locationIndex] = ismember('EvenAsphere',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;  
                elseif strcmpi(zemaxSurfaceType,'TOROIDAL')
                    [~,locationIndex] = ismember('Toroidal',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;      
                else
                    disp(['Surf ',num2str(surfaceCounter),' Error: Surface '...
                        'type: ',zemaxSurfaceType,' is not supported. It is cosidered as STANDARD' ]);
                    [~,locationIndex] = ismember('Standard',supportedSurfaceTypes);
                    surfaceObjectArray(surfaceCounter).Type = locationIndex;
                end
                % Initialize all surface specific data
                % Other surface type specific standard data
                [~,~,~,uniqueParameterStruct] = getSurfaceUniqueParameters(surfaceObjectArray(surfaceCounter).Type);
                surfaceObjectArray(surfaceCounter).UniqueParameters = uniqueParameterStruct;
                
            case 'GLAS'
                % GLAS name code psurf nd vd pd vnd vvd vpd io ao	Glass
                % name: The name of the glass or "___BLANK" if glass name is not given or "MIRROR" if mirror.
                % code: The glass type used. 0(Fixed or Mirror),1(Model),2(Pickup),3(Substitute),4(Offset)
                % psurf: Pickup Surface index. Only used for pickup surfaces and 0 otherwise.
                % nd,vd and pd: The index, abbe number and partial disperssion for the glass (but used only for model glass).
                % vnd,vvd and vpd: Variablity status of nd,vd and pd.
                % io and ao: Offset values (index offset and abbe offset)
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Importing '...
                        'glass is not fully supported.Needs checking.' ]);
                end
                name = char(currentLineArray(2,:));
                code = str2num(char(currentLineArray(3,:)));
                psurf = str2num(char(currentLineArray(4,:)));
                nd = str2num(char(currentLineArray(5,:)));
                vd = str2num(char(currentLineArray(6,:)));
                pd = str2num(char(currentLineArray(7,:)));
                vnd = str2num(char(currentLineArray(8,:)));
                vvd = str2num(char(currentLineArray(9,:)));
                vpd = str2num(char(currentLineArray(10,:)));
                io = str2num(char(currentLineArray(11,:)));
                ao = str2num(char(currentLineArray(12,:)));
                
                if strcmpi(name,'MIRROR')
                    % Just take the glass of the non dummy surface before the mirror
                    % but with the new name "MIRROR"
                    for pp = surfaceCounter-1:-1:1
                        if nonDummySurface(pp)
                            prevNonDummySurface = pp;
                            break;
                        end
                    end
                    aodObject = surfaceObjectArray(prevNonDummySurface).Glass;
                    aodObject.Name = 'MIRROR';
                    surfaceObjectArray(surfaceCounter).Glass = aodObject;
                    
                else
                    % glasss data
                    % get glass name and then SellmeierCoefficients from file
                    glassName = char(currentLineArray(2,:));
                    if ~isempty(glassName)
                        if ~strcmpi(glassName,'___BLANK')
                            % check for its existance and extract the glass among selected catalogues
                            objectType = 'glass';
                            objectName = glassName;
                            if isnan(str2double(glassName)) % If the glass name is specified
                                objectCatalogueListFullNames = glassCatalogueListFullNames;
                                objectIndex = 0;
                                for pp = 1:size(objectCatalogueListFullNames,1)
                                    objectCatalogueFullName = objectCatalogueListFullNames{pp};
                                    [ aodObject,objectIndex ] = extractObjectFromObjectCatalogue...
                                        (objectType,objectName,objectCatalogueFullName );
                                    if objectIndex ~= 0
                                        break;
                                    end
                                end
                                
                                if  objectIndex ~= 0
                                    surfaceObjectArray(surfaceCounter).Glass = aodObject;
                                else
                                    disp(['Surf ',num2str(surfaceCounter),'Error: The glass after surface ',num2str(surfaceCounter),' is not found so it is ignored.']);
                                    surfaceObjectArray(surfaceCounter).Glass = Glass;
                                end
                            else
                                aodObject = Glass(glassName);
                                surfaceObjectArray(surfaceCounter).Glass = aodObject;
                            end
                        else
                            if code == 1 % Model  / fixed index glass
                                glassName = [num2str((nd),'%.4f '),',',...
                                    num2str((vd),'%.4f '),',',...
                                    num2str((pd),'%.4f ')];
                                aodObject = Glass(glassName,'FixedIndex',[nd,vd,pd,0,0,0,0,0,0,0]');
                                surfaceObjectArray(surfaceCounter).Glass = aodObject;
                            end
                        end
                    else
                        surfaceObjectArray(surfaceCounter).Glass = Glass;
                    end
                end
                
                
            case 'DIAM'
                % DIAM val solveType param1 param2 param3 param4	The surface semidiameter.
                % Val: value of the semidiameter
                % solveType = 0 (automatic), 1(fixed),2(pickup),3(maximum),4(zpl macro)… indicating the solve types (see the solves chapter from Zemax manual)
                % param1…4 : Solve parameters
                %
                semidiam = str2num(char(currentLineArray(2,:)));
                solveType = str2num(char(currentLineArray(3,:)));
                if solveType == 1
                    % If fixed semidiameter, then make the draw absolute
                    % value of the aperture True
                    surfaceApertureIsFixedSize = 1;
                    if  mySystem.SystemApertureType == 3 && surfaceObjectArray(surfaceCounter).StopSurfaceIndex
                        % If fixed semidiameter, system aperture float by stop size and current surface is stop
                        [~,circApertureIndex] = ismember('CircularAperture',GetSupportedSurfaceApertureTypes);
                        surfaceObjectArray(surfaceCounter).Aperture.Type = circApertureIndex;
                        surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.SmallDiameter = 0;
                        surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters.LargeDiameter = 2*semidiam;
                        surfaceApertureIsSet = 1;
                    end
                end
                if dispWarnings
                    if solveType
                        disp(['Surf ',num2str(surfaceCounter),' Warning: Semidiameter '...
                            ' solve/pickup is not supported.' ]);
                    end
                end
                
                % Set the aperture values if it is floating or None
                if strcmpi(surfaceObjectArray(surfaceCounter).Aperture.Type,'FloatingCircularAperture')||...
                        strcmpi(surfaceObjectArray(surfaceCounter).Aperture.Type,'None')
                    aperParam = surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters;
                    
                    if strcmpi(zemaxSurfaceType,'TILTSURF')
                        % For tilt surface the semidiameter and aperture values
                        % given in zemax are not the actual values rather they
                        % are projections on x and y plane. So shall be converted
                        % to actual values.
                        tiltX = surfaceObjectArray(surfaceCounter).Tilt(1);
                        tiltY = surfaceObjectArray(surfaceCounter).Tilt(2);
                        apertureFactorX = abs(1/cos(tiltY*pi/180));
                        apertureFactorY = abs(1/cos(tiltX*pi/180));
                    else
                        apertureFactorX = 1;
                        apertureFactorY = 1;
                    end
                    aperParam.Diameter = 2*semidiam*apertureFactorX;
                    surfaceObjectArray(surfaceCounter).Aperture.AdditionalEdge = mySystem.SurfaceMarginPercent/100;
                    
                    surfaceObjectArray(surfaceCounter).Aperture.UniqueParameters = aperParam;
                end
                
            case  'DISZ'
                % DISZ val: The Z thickness of the surface.
                thick = (char(currentLineArray(2,:)));
                if strcmpi(thick,'INFINITY')|| strcmpi(thick,'INF')
                    thick = Inf;
                else
                    thick = str2num(thick);
                end
                surfaceObjectArray(surfaceCounter).Thickness = thick;
            case {'CHZH', 'EDGE','MAZH','OPDZ' ,'PZUP' ,...
                    'TCOC','TCOM' ,'TOLE','TPUP','VDSZ'}
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Thickness '...
                        ' solve/pickup is not supported.' ]);
                end
            case 'SCBD'
                % SCBD beforeAfter order pickupType decX decY tiltX tiltY tiltZ	SCBD => ??TILT AND DECENTER DATA
                % beforeAfter: 1(before surface) , 2(after surface)
                % order: 0(Decenter,Tilt), 1(Tilt,Decenter)
                % pickupType:0(Explicit), 1(Pick This Surf), 2(Reverse This Surf), 3(Pick This Surf-1), 4(Reverse This Surf-1),..., 2n+1(Pick Surf - n), 2n+2(Reverse Surf - n )
                % decX decY tiltX tiltY tiltZ
                disp(['Surf ',num2str(surfaceCounter),'Error: Tilt and decenter data for surface is not currently',...
                    ' supported. Please use Coordinate break surface instead.']);
            case 'PARM'
                % PARM n val	Parameter n is the value of "val".
                n = str2num(char(currentLineArray(2,:)));
                value = str2num(char(currentLineArray(3,:)));
                if  strcmpi(zemaxSurfaceType,'COORDBRK')
                    switch n
                        case 0
                            % Unused
                        case 1
                            decParam = surfaceObjectArray(surfaceCounter).Decenter;
                            decParam(1) = value;
                            surfaceObjectArray(surfaceCounter).Decenter = decParam;
                        case 2
                            decParam = surfaceObjectArray(surfaceCounter).Decenter;
                            decParam(2) = value;
                            surfaceObjectArray(surfaceCounter).Decenter = decParam;
                        case 3
                            tiltParam = surfaceObjectArray(surfaceCounter).Tilt;
                            tiltParam(1) = value;
                            surfaceObjectArray(surfaceCounter).Tilt = tiltParam;
                        case 4
                            tiltParam = surfaceObjectArray(surfaceCounter).Tilt;
                            tiltParam(2) = value;
                            surfaceObjectArray(surfaceCounter).Tilt = tiltParam;
                        case 5
                            tiltParam = surfaceObjectArray(surfaceCounter).Tilt;
                            tiltParam(3) = value;
                            surfaceObjectArray(surfaceCounter).Tilt = tiltParam;
                        case 6
                            order = value;
                            if order == 0 % D->T
                                surfaceObjectArray(surfaceCounter).TiltDecenterOrder = 1;%{'Dx','Dy','Dz','Tx','Ty','Tz'};
                            else % T->D
                                surfaceObjectArray(surfaceCounter).TiltDecenterOrder = 2;%{'Tx','Ty','Tz','Dx','Dy','Dz'};
                            end
                            surfaceObjectArray(surfaceCounter).TiltMode = 2;%'NAX';
                    end
                elseif strcmpi(zemaxSurfaceType,'TILTSURF')
                    tiltParam = surfaceObjectArray(surfaceCounter).Tilt;
                    switch n
                        case 0
                            % Unused
                        case 1
                            % An angle from x axis => Rotation about y axis
                            tiltParam(2) = atan(value)*180/pi;
                        case 2
                            % An angle from y axis => Rotation about x axis
                            tiltParam(1) = atan(value)*180/pi;
                    end
                    surfaceObjectArray(surfaceCounter).Tilt = tiltParam;
                elseif strcmpi(zemaxSurfaceType,'DGRATING')
                    grating = surfaceObjectArray(surfaceCounter).Grating;
                    switch n
                        case 0
                            % Unused
                        case 1
                            % Lines per um
                            grating.UniqueParameters.LinesPerMicrometer = value;
                        case 2
                            % DiffractionOrder
                            grating.DiffractionOrder = value;
                    end
                    surfaceObjectArray(surfaceCounter).Grating = grating;
                elseif strcmpi(zemaxSurfaceType,'TOROIDAL')
                    suraceParameters = surfaceObjectArray(surfaceCounter).UniqueParameters;
                    switch n
                        case 0
                            % Extrapolate not used currently
                        case 1
                            % RadiusOfRotation
                            if value == 0
                                value = Inf; % In zemax Inf radius of curv is set as 0
                            end
                            suraceParameters.RadiusOfRotation = value;
                        case 2
                            % C2
                            suraceParameters.C2 = value;
                        case 3
                            % C4
                            suraceParameters.C4 = value;
                        case 4
                            % C6
                            suraceParameters.C6 = value;
                        case 5
                            % C8
                            suraceParameters.C8 = value;
                        case 6
                            % C10
                            suraceParameters.C10 = value;
                        case 7
                            % C12
                            suraceParameters.C12 = value;
                        case 8
                            % C14
                            suraceParameters.C14 = value;    
                    end
                    surfaceObjectArray(surfaceCounter).UniqueParameters = suraceParameters;    
                elseif strcmpi(zemaxSurfaceType,'EVENASPH')
                    suraceParameters = surfaceObjectArray(surfaceCounter).UniqueParameters;
                    switch n
                        case 0
                            % Unused
                        case 1
                            % C2
                            suraceParameters.C2 = value;
                        case 2
                            % C4
                            suraceParameters.C4 = value;
                        case 3
                            % C6
                            suraceParameters.C6 = value;
                        case 4
                            % C8
                            suraceParameters.C8 = value;
                        case 5
                            % C10
                            suraceParameters.C10 = value;
                        case 6
                            % C12
                            suraceParameters.C12 = value;
                        case 7
                            % C14
                            suraceParameters.C14 = value;
                        case 8
                            % C16
                            suraceParameters.C16 = value;       
                    end
                    surfaceObjectArray(surfaceCounter).UniqueParameters = suraceParameters;    
                else
                end
            case 'VPAR'
                % specify variable for optimization
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: '...
                        ' Optimization variables are ignored.' ]);
                end
            case 'PPAR'
                % Unknown keyword
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: PPAR '...
                        ' is not known keyword yet.' ]);
                end
            case 'XDAT'
                % Extra data
                if dispWarnings
                    disp(['Surf ',num2str(surfaceCounter),' Warning: Extra '...
                        ' data is not supported.' ]);
                end
            otherwise
                disp([zmxSurfCommand,' for surface ',num2str(surfaceCounter),...
                    'is not included in the zemax importer. ',...
                    'Please add the command in the function to import your file properly. '])
        end
        prevCommand = zmxSurfCommand;
        currentLine = readNextLine(inputFile);
        % read the line as space separated string
        currentLineArray = strread(currentLine,'%s');
        % The first element of the array is the 4 character zmx command
        zmxSurfCommand = char(currentLineArray(1,:));
        if ~isSurfaceCommand(zmxSurfCommand)
            % Mark end of surface definition
            endOfSurfaceDefinition = 1;
        end
    end
    
    nSurf = size(surfaceObjectArray,2);
    nonDummySurface = nonDummySurface(1:nSurf);
    nonDummySurfaceIndices = find(nonDummySurface);
    nextZmxCommand = zmxSurfCommand;
end

function isSurfCommand = isSurfaceCommand(zmxSurfCommand)
    surfaceCommands = {'HIDE','POPS','MIRR','CLAP','ELAP','ELOB','FLAP',...
        'OBDC','OBSC','SPID','SQAP','SQOB','UDAD','USAP','USOB','COAT',...
        'COMM', 'CONI','VCON','PKUP','CURV','SCOL','SLAB','STOP','SURF',...
        'TYPE','GLAS','DIAM','DISZ','CHZH', 'EDGE','MAZH','OPDZ' ,'PZUP' ,...
        'TCOC','TCOM' ,'TOLE','TPUP','VDSZ','SCBD','PARM','VPAR','PPAR','XDAT',...
        'FIMP','LANG',};
    isSurfCommand = ismember(upper(zmxSurfCommand),surfaceCommands);
end